#include "Plans/Serve/constraints/DriveToPOI1519913821580Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1519913821580) ENABLED START*/
#include <TTBWorldModel.h>
#include <TurtleBot.h>
#include <alica/reasoner/DummyTerm.h>
#include <alica/reasoner/DummyVariable.h>
#include <engine/RunningPlan.h>
#include <engine/constraintmodul/ProblemDescriptor.h>
#include <engine/constraintmodul/SolverTerm.h>
#include <engine/constraintmodul/SolverVariable.h>
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:DriveToPOI

    /*		
     * Tasks: 
     * - EP:1519913874346 : DefaultTask (1414681164704)
     *
     * States:
     * - DriveToPOI (1519913874345)
     * - OpenDoor (1519913892405)
     * - AtGoalPOI (1519914080351)
     * - WasBlocked (1519914308674)
     *
     * Vars:				
     * - door (1519913984042) 				
     * - poi (1519913989387) 
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString): 
     * Static Variables: [door, poi]
     * Domain Variables:

     */
    void Constraint1519914269940::getConstraint(shared_ptr<ProblemDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1519914269940) ENABLED START*/
        auto wm = ttb::TTBWorldModel::get();
        auto currentTask = wm->taskManager.getNextTask();
        if (!currentTask || currentTask->getInformation().type != ttb_msgs::ServeTask::DRIVE_TO)
        {
            // current task is not for driving to an POI, so don't specify any problem descriptor
            std::cout << "1" << std::endl;
            return;
        }

        // POI Variable
        auto currentGoalPOI = wm->topologicalModel.getPOI(stoi(currentTask->getInformation().entity));
        if (!currentGoalPOI)
        {
            // unable to get the goalPOI
            std::cout << "2" << std::endl;
            return;
        }

        auto robot = ttb::TurtleBot::get(wm);
        auto nextPOI = robot->movement->getNextPOI(currentGoalPOI);
        if (!nextPOI)
        {
            // unable to get nextPOI
            std::cout << "3" << std::endl;
            return;
        }

        auto constraint = std::make_shared<alica::reasoner::DummyTerm>();
        auto dummyPOIVar = std::dynamic_pointer_cast < alica::reasoner::DummyVariable > (c->getStaticVars()->at(1));
        if (dummyPOIVar)
        {
            constraint->setVariable(dummyPOIVar, to_string(nextPOI->id));
        }
        else
        {
            std::cerr << "Constraint1519914269940: Variable type of POI didn't fit!" << std::endl;
        }

        // DOOR Variable
        auto dummyDoorVar = std::dynamic_pointer_cast < alica::reasoner::DummyVariable > (c->getStaticVars()->at(0));
        if (!dummyDoorVar)
        {
            std::cerr << "Constraint1519914269940: Variable type of door didn't fit!" << std::endl;
        }
        else
        {
            // is there a door between us and the next POI?
            if (!wm->robot.inSameRoom(nextPOI))
            {
                auto nextDoor = robot->movement->getNextDoor(nextPOI);
                if (!nextDoor)
                {
                    constraint->setVariable(dummyDoorVar, alica::reasoner::DummyVariable::NO_VALUE);
                    return;
                }
                constraint->setVariable(dummyDoorVar, nextDoor->name);
            }
            else
            {
                constraint->setVariable(dummyDoorVar, alica::reasoner::DummyVariable::NO_VALUE);
            }
        }

        c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
        /*PROTECTED REGION END*/
    }

// State: DriveToPOI

// State: DriveToPOI

// State: OpenDoor

// State: OpenDoor

// State: AtGoalPOI

// State: AtGoalPOI

// State: WasBlocked

// State: WasBlocked

}
